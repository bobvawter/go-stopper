// Copyright 2026 Bob Vawter (bob@vawter.org)
// SPDX-License-Identifier: Apache-2.0

package stopper

import (
	"slices"
	"time"
)

// DefaultGracePeriod is the amount of time a stopper will remain in a
// soft-stop condition before moving into a hard-stop condition.
const DefaultGracePeriod = 10 * time.Second

// An ErrorHandler is called whenever a task passed to [Context.Go]
// returns a non-nil error.
type ErrorHandler func(ctx Context, err error)

// ErrorHandlerStop is the default handler that will call [Context.Stop]
// immediately upon task failure. The received error will be available
// from [Context.Wait].
var ErrorHandlerStop ErrorHandler = func(ctx Context, err error) {
	ctx.AddError(err)
	ctx.Stop()
}

// ErrorHandlerRecord will append a task error to the Context but will
// not cause the Context to stop. Caution should be taken if the Context
// processes an unbounded number of tasks. The received errors will be
// available from [Context.Wait].
var ErrorHandlerRecord ErrorHandler = func(ctx Context, err error) {
	ctx.AddError(err)
}

// A Middleware allows behaviors to be injected into the setup and
// execution of a task.
//
// A Middleware factory has a synchronous setup phase during during a
// call to [Context.Go] or [Context.Call]. It may capture any necessary
// state from the task initiator's context and optionally provide an
// amended Context, generally via [Context.WithDelegate].
//
// The [Invoker] returned by a Middleware will be executed in the task's
// goroutine, using the Context returned by the last Middleware in the
// chain.
type Middleware func(outer Context) (Context, Invoker)

// Invoker is the result of having called a Middleware and is called
// from the goroutine executing the task with the task's [Context]. An
// [Invoker] may choose to short-circuit the execution of the provided
// task.  If so, the error returned by the [Invoker] will be used in
// place of the task's return value.
type Invoker func(ctx Context, task Func) error

// InvokerCall is an [Invoker] that just calls its tasks.
var InvokerCall Invoker = func(ctx Context, task Func) error {
	return task(ctx)
}

// InvokerDrop is an [Invoker] that always returns nil.
var InvokerDrop Invoker = func(_ Context, _ Func) error {
	return nil
}

// InvokerErr returns an [Invoker] that will return the provided error.
func InvokerErr(err error) Invoker {
	return func(_ Context, _ Func) error {
		return err
	}
}

type config struct {
	name        string
	noInherit   bool
	noTaskInfo  bool
	gracePeriod *time.Duration
	taskOpts    *task
}

// Clone returns a deep copy of the config.
func (c *config) Clone() *config {
	return &config{
		name:        c.name,
		noInherit:   c.noInherit,
		noTaskInfo:  c.noTaskInfo,
		gracePeriod: c.gracePeriod,
		taskOpts:    c.taskOpts.Clone(),
	}
}

// Merge incorporates any settings defined in the provided config.
func (c *config) Merge(o *config) {
	// Reset to a zero value if inheritance has been disabled.
	if o.noInherit {
		*c = config{}
	}
	if o.name != "" {
		if c.name == "" {
			c.name = o.name
		} else {
			c.name = c.name + "." + o.name
		}
	}
	if o.noTaskInfo {
		c.noTaskInfo = true
	}
	if o.gracePeriod != nil {
		c.gracePeriod = o.gracePeriod
	}
	if o.taskOpts != nil {
		if c.taskOpts == nil {
			c.taskOpts = o.taskOpts
		} else {
			c.taskOpts.Merge(o.taskOpts)
		}
	}
}

// Sanitize ensures that reasonable defaults have been set.
func (c *config) Sanitize() {
	if c.name == "" {
		c.name = "stopper"
	}
	if c.gracePeriod == nil {
		g := DefaultGracePeriod
		c.gracePeriod = &g
	}
	if c.taskOpts == nil {
		c.taskOpts = &task{}
	}
	c.taskOpts.Sanitize()
}

// A ConfigOption may be passed to [New] or to [WithContext].
type ConfigOption func(*config)

// WithGracePeriod overrides the stopper's default grace period
// ([DefaultGracePeriod]) for allowing tasks to soft-stop before the
// stopper moves into a hard-stop condition.
func WithGracePeriod(gracePeriod time.Duration) ConfigOption {
	return func(c *config) {
		c.gracePeriod = &gracePeriod
	}
}

// WithName sets a display string to associate with any error messages
// generated by the stopper.
func WithName(name string) ConfigOption {
	return func(c *config) {
		c.name = name
	}
}

// WithNoInherit prevents any configuration options provided to parent
// stopper Context(s) from being merged into the stopper being created.
func WithNoInherit() ConfigOption {
	return func(c *config) {
		c.noInherit = true
	}
}

// WithNoTaskInfo disables the attachment of [TaskInfo] to runtime
// contexts if no observability [Middleware] is enabled.
func WithNoTaskInfo() ConfigOption {
	return func(c *config) {
		c.noTaskInfo = true
	}
}

// WithTaskOptions provides default task options for [Context.Call] or
// [Context.Go]. These default options may be overridden at individual
// call sites.
func WithTaskOptions(opts ...TaskOption) ConfigOption {
	return func(c *config) {
		c.taskOpts = applyTaskOpts(c.taskOpts, opts)
	}
}

type stop struct {
	gracePeriod *time.Duration
	onIdle      bool
}

// Sanitize ensures that reasonable defaults have been set.
func (s *stop) Sanitize() {
	// Currently a no-op, exists to prevent future footguns.
}

// A StopOption may be passed to [Context.Stop].
type StopOption func(*stop)

// StopGracePeriod overrides the stopper's grace period for allowing
// tasks to soft-stop before the stopper moves into a hard-stop
// condition.
func StopGracePeriod(gracePeriod time.Duration) StopOption {
	return func(stop *stop) {
		stop.gracePeriod = &gracePeriod
	}
}

// StopOnIdle delays the effects of the call to [Context.Stop] until the
// [Context] has no more active tasks. This can be used for (child)
// stoppers that represent a bounded pool of work.
func StopOnIdle() StopOption {
	return func(stop *stop) {
		stop.onIdle = true
	}
}

type task struct {
	errHandler ErrorHandler
	name       string
	noInherit  bool
	mw         []Middleware
}

// Apply the options to the target configuration. If the options modify
// the base configuration, a new instance will be returned.
func applyTaskOpts(base *task, opts []TaskOption) *task {
	// Return unmodified if no additional options.
	if len(opts) == 0 {
		return base
	}
	// Execute the option functions to produce intermediate config.
	next := &task{}
	for _, opt := range opts {
		opt(next)
	}
	// Return intermediate if no base or if no-inherit flag is set.
	if base == nil || next.noInherit {
		next.Sanitize()
		return next
	}
	// Merge the intermediate into a copy of the base.
	ret := base.Clone()
	ret.Merge(next)
	ret.Sanitize()
	return ret
}

// Clone returns a deep copy of the task.
func (t *task) Clone() *task {
	return &task{
		errHandler: t.errHandler,
		name:       t.name,
		noInherit:  t.noInherit,
		mw:         slices.Clone(t.mw),
	}
}

// Merge updates the receiver with additional configuration.
func (t *task) Merge(o *task) {
	if o.errHandler != nil {
		t.errHandler = o.errHandler
	}
	if o.name != "" {
		t.name = o.name
	}
	if len(o.mw) > 0 {
		t.mw = append(t.mw, o.mw...)
	}
}

// Sanitize ensures that reasonable defaults have been set.
func (t *task) Sanitize() {
	if t.errHandler == nil {
		t.errHandler = ErrorHandlerStop
	}
	if t.name == "" {
		t.name = "task"
	}
}

// A TaskOption may be passed to [Context.Call] or [Context.Go].
type TaskOption func(*task)

// TaskName provides a display string to associate with any error
// messages associated with the task.
func TaskName(name string) TaskOption {
	return func(t *task) {
		t.name = name
	}
}

// TaskErrHandler provides a means of handling errors from asynchronous
// tasks.
func TaskErrHandler(h ErrorHandler) TaskOption {
	return func(t *task) {
		t.errHandler = h
	}
}

// TaskMiddleware applies the given Middleware to the execution of a
// single task.
func TaskMiddleware(mw ...Middleware) TaskOption {
	return func(cfg *task) {
		cfg.mw = append(cfg.mw, mw...)
	}
}

// TaskNoInherit disables any inherited TaskOptions that were provided
// to the stopper constructor via [WithTaskOptions].
func TaskNoInherit() TaskOption {
	return func(t *task) {
		t.noInherit = true
	}
}
